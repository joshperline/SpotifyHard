import java.util.ArrayList;
import java.util.LinkedList;
import java.util.HashMap;
import java.io.BufferedReader;
import java.io.InputStreamReader;

/** Spotify Programming Lab: Level "HARD"
 *  "Cats vs Dogs"
 *  @author Joshua Perline
 */

public class CatVsDog {
    
    /** Reads from Standard Input, input files are IGNORED.
     *  Performs N test cases s.t. N = the integer on the first line of input. 
     *  Outputs the maximum number of satisfied voters given the test case.
     *  Treats each case as a Bipartite graph, with voters represented as
     *  directed edges: v0 = keep, v1 = vote off. */
    public static void main(String[] ignored) { 
	BufferedReader reader =
	     new BufferedReader(new InputStreamReader(System.in));
	int c = 0;
	int d = 0;
	int v = 0;
	resetData();
	_no = new NoLabel();
	try {
	    String read;		
	    int vote = 0;
	    int cases = 0;
	    int currCase = 0;
	    read = reader.readLine();
	    String[] firstLine = read.split("\\s+");
	    cases = Integer.parseInt(firstLine[0]);
	    for (int i = 0; i < cases; i += 1) {
		read = reader.readLine();
		String[] line = read.split("\\s+");
	        if (line.length == 3) {
		    resetData();
		    c = Integer.parseInt(line[0]);
		    d = Integer.parseInt(line[1]);
		    v = Integer.parseInt(line[2]);
		    for (int k = 0; k < v; k += 1) {
			read = reader.readLine();
			addToGraph(read);
		    }
		    createEdges();
		    System.out.println(v - hopcroftKarp());
		}
	    }
	} catch (Exception e) {
	    e.printStackTrace();
	}
    }

    private static ArrayList<Graph<Vote, NoLabel>.Vertex> _catVerts, _dogVerts;

    private static void addToGraph(String entry) {//gather shit up vertices	
	if (entry.substring(0, 1).equals("C")) {
	    _catVerts.add(_G.add(new Vote(entry)));
	} else {
	    _dogVerts.add(_G.add(new Vote(entry)));
	}
    }

    private static void createEdges() {//make edges
	for (Graph<Vote, NoLabel>.Vertex cat: _catVerts) {
	    for (Graph<Vote, NoLabel>.Vertex dog: _dogVerts) {
		if (cat.getLabel().isContradiction(dog.getLabel())) {
		    _G.add(cat, dog, _no);
		}
	    }
	}
    }

    /** Builds a Bipartite graph G = G1 U G2 U NIL s.t.
     *  G1 contains all cat vertices
     *  G2 contains all dog vertices
     *  NIL is a special null vertex: _nil
     *  Edges are directed (with no label) based on a voter's vote
     *  i.e. if voter is a cat lover: v0 = Cx, v1 = Dy.*/
    // private static void addToGraph(String[] line) {
    // 	if (line[0].substring(0, 1).equals("C")) {//dog keep
    // 	    String cGood = line[0].substring(1, 2);
    // 	    String cBad = line[1].substring(1, 2);
    // 	    if (!_cats.keySet().contains(cGood)) {
    // 		_cats.put(cGood,
    // 			  new Pet(cGood));
    // 		_catVert.put(_cats.get(cGood),
    // 			     _G.add(_cats.get(cGood)));
    // 	    }
    // 	    if (!_dogs.keySet().contains(cBad)) {
    // 		_dogs.put(cBad,
    // 			  new Pet(cBad));
    // 		_dogVert.put(_dogs.get(cBad),
    // 			     _G.add(_dogs.get(cBad)));
    // 	    }
    // 	    _G.add(_catVert.get(_cats.get(cGood)),
    // 		   _dogVert.get(_dogs.get(cBad)), _no);
    // 	} else if (line[0].substring(0, 1).equals("D")) {//Cat keep
    // 	    String dGood = line[0].substring(1, 2);
    // 	    String dBad = line[1].substring(1, 2);
    // 	    if (!_dogs.keySet().contains(dGood)) {
    // 		_dogs.put(dGood,
    // 			  new Pet(dGood));
    // 		_dogVert.put(_dogs.get(dGood),
    // 			     _G.add(_dogs.get(dGood)));
    // 	    }
    // 	    if (!_cats.keySet().contains(dBad)) {
    // 		_dogs.put(dBad,
    // 			 new Pet(dBad));
    // 		_dogVert.put(_dogs.get(dBad),
    // 			     _G.add(_dogs.get(dBad)));
    // 	    }
    // 	    _G.add(_dogVert.get(_dogs.get(dGood)),
    // 		   _catVert.get(_cats.get(dBad)), _no);
    // 	}
    // }

    /** Solves test cases by performing a Hopcroft-Karp search 
     *  in order to find the maximum number of satisfied voters s.t.
     *  Max(satisfied) = N voters - the total matchings. */
    private static int hopcroftKarp() {
	_nilMap = new HashMap<>();
	dist = new HashMap<>();
	for (Graph<Vote, NoLabel>.Vertex v : _G.vertices()) {
	    dist.put(v, Integer.MAX_VALUE);
	}
	int matching = 0;
	while (BFS()) {
	    for (Graph<Vote, NoLabel>.Vertex cat: _catVerts) {
		if (_nilMap.get(cat) == null) {
		    if (DFS(cat)) {
			matching += 1;
		    }
		}
	    }
	}
	return matching;
    }

    /** Performs BFS on Graph in order to partition the graph to be later
     *  traversed using DFS, as only unmatched edges may be traversed. */
    private static boolean BFS() {
	LinkedList<Graph<Vote, NoLabel>.Vertex> Q =
            new LinkedList<>();
	for (Graph<Vote, NoLabel>.Vertex cat : _catVerts) {
	    if (_nilMap.get(cat) == null) {
		dist.put(cat, 0);
		Q.add(cat);
	    } else {
		dist.put(cat, Integer.MAX_VALUE);
	    }
	}
	dist.put(null, Integer.MAX_VALUE);
	while (!Q.isEmpty()) {
	    Graph<Vote, NoLabel>.Vertex v = Q.poll();
	    if (v != null) {
		for (Graph<Vote, NoLabel>.Vertex u : _G.successors(v)) {
		    if (dist.get(_nilMap.get(u)) == Integer.MAX_VALUE) {
			dist.put(_nilMap.get(u), dist.get(v) + 1);
			Q.add(_nilMap.get(u));
		    }
		}
	    }
	}
	return dist.get(null) != Integer.MAX_VALUE;
    }

    /** Performs a DFS on vertex, V, in order to try and find cycles in the graph.
      *  Returns true iff a cycle occurs, thus stating a contradiction exists. */
    private static boolean DFS(Graph<Vote, NoLabel>.Vertex v) {
	if (v != null) {
	    for (Graph<Vote, NoLabel>.Vertex u : _G.successors(v)) {
		if (dist.get(_nilMap.get(u)) == dist.get(v) + 1) {
		    if (DFS(_nilMap.get(u))) {
			_nilMap.put(u, v);
			_nilMap.put(v, u);
			return true;
		    }
		}
	    }
	    dist.put(v, Integer.MAX_VALUE);
	    return false;
	}
	return true;
    }

    static class Vote {
	/** Contsrtuctor takes in ID value. */
	Vote(String id) {
	    _id = id;
	}

	boolean isContradiction(Vote vote) {
	    return this.getID().equals(vote.getOpposite());
	}

	/** The ID value of a pet. */
	private String _id;
	
	/** Returns the id of the pet. Useful for testing. */
	String getID() {
	    return _id;
	}

	String getOpposite() {
	    if (_id.substring(0, 1).equals("C")) {
		return ("D" + _id.substring(1, 2)
			+ " " + "C" + _id.substring(4, 5));
	    } else {
		return ("C" + _id.substring(1, 2)
			+ " " + "D" + _id.substring(4, 5));
	    }
	}
    }


    /** An object that serves as a Vertex label in the Bipartite graph of "pets."
     *  Takes in an ID (i.e. C1, C2, D3, D5), and has setter and getter methods
     *  for its String representation. */
    static class Pet {
	/** Contsrtuctor takes in ID value. */
	Pet(String id) {
	    _id = id;
	}
	
	/** The ID value of a pet. */
	private String _id;
	
	/** Returns the id of the pet. Useful for testing. */
	String getID() {
	    return _id;
	}
    }
    
    /** Re-instantiates all instance variables and data structures. */
    private static void resetData() {
	_G = new UndirectedGraph<Vote, NoLabel>();
	_catVerts = new ArrayList<>();
	_dogVerts = new ArrayList<>();
	_dogs = new HashMap<>();
	_cats = new HashMap<>();
	_dogVert = new HashMap<>();
	_catVert = new HashMap<>();
	_nilMap = new HashMap<>();
    }

    
    /* ---------------------------- Data Structures ------------------------------ */


    /** The current graph. */
    private static UndirectedGraph<Vote, NoLabel> _G;

    /** Maps a String (i.e. C1, D1) to its Pet object counterpart
     *  in order to alleviate the risk of confused pointers. */
    private static HashMap<String, Vote> _dogs, _cats;

    /** Maps Pet to its Vertex counterpart in the graph.
     *  _catVert serves as G1
     *  _dogVert serves as G2
     *  s.t. G = G1 U G2 U NIL. */
    private static HashMap<Vote, UndirectedGraph<Vote, NoLabel>.Vertex>
	_catVert, _dogVert;
   
    /** NoLabel placeholder object to be used in lieu of ELabels. */
    private static NoLabel _no;

    /** Determines if Vertex should be traversed over in G1 or G2. 
     *  Aides in representing the NIL partition of G by mapping Vertices to NULL. */
    private static HashMap<Graph<Vote, NoLabel>.Vertex, Graph<Vote, NoLabel>.Vertex>
	_nilMap;

    /** Maps Vertices to its heuristic distance value. */
    private static HashMap<Graph<Vote, NoLabel>.Vertex, Integer> dist;

}
